<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
			body { margin: 0; }
		</style>
	</head>
  </head>
  <body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
      import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000 );

      const renderer = new THREE.WebGLRenderer({alpha:true,antialias :true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      				// controls
      const controls = new OrbitControls(camera,renderer.domElement );
      controls.update();

      const imageLoader = new THREE.ImageLoader();

      const textureLoader = new THREE.TextureLoader();

      const loader = new OBJLoader();
      loader.load(
        '/public/BY_N_textured.obj',
        (object)=> {
          object.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
                // 创建材质数组
                var materials = [];
                // 加载多张图片
                var textureUrls = [
                    textureLoader.load('/public/BY_N_textured0.png'),
                    textureLoader.load('/public/BY_N_textured1.png'),
                    textureLoader.load('/public/BY_N_textured2.png')
                ];

                // 为每个面创建材质，并将图片贴上
                for (let i = 0; i < child.geometry.groups.length; i++) {
                    let material = new THREE.MeshStandardMaterial({ map: textureUrls[i] });
                    materials.push(material);
                }
                child.material = materials;
            }
        });



          // compute the box that contains all the stuff
          // from root and below
          const box = new THREE.Box3().setFromObject(object);
          const boxSize = box.getSize(new THREE.Vector3()).length();
          const boxCenter = box.getCenter(new THREE.Vector3());

          // set the camera to frame the box
          frameArea(boxSize * 1.2, boxSize, boxCenter, camera);

          // update the Trackball controls to handle the new size
          controls.maxDistance = boxSize * 10;
          controls.target.copy(boxCenter);
          controls.update();

          const color = 0xFFFFFF;
          const intensity = 1;
          const light = new THREE.DirectionalLight(color, intensity);
          light.position.set(-30, 24, -60);
          scene.add(light);
          scene.add(light.target);
          scene.add(object)

        },
        // called when loading is in progresses
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
        },
        // called when loading has errors
        function (error) {
          console.log('An error happened',error);
        }
      );





    const frameArea = (sizeToFitOnScreen, boxSize, boxCenter, camera)=> {
      const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
      const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
      const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
      // compute a unit vector that points in the direction the camera is now
      // in the xz plane from the center of the box
      const direction = (new THREE.Vector3())
          .subVectors(camera.position, boxCenter)
          .multiply(new THREE.Vector3(1, 0, 1))
          .normalize();

      // move the camera to a position distance units way from the center
      // in whatever direction the camera was from the center already
      camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

      // pick some near and far values for the frustum that
      // will contain the box.
      camera.near = boxSize / 100;
      camera.far = boxSize * 100;

      camera.updateProjectionMatrix();

      // point the camera to look at the center of the box
      camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
    }
    const render = () => {
        renderer.render( scene, camera );
        requestAnimationFrame(render)
      }
      render();
    </script>
  </body>
</html>
